<?php

namespace PP\SampleBundle\Entity\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\Common\Persistence\ObjectManager;
use Doctrine\Common\Collections\Criteria;

use PP\SampleBundle\Entity\ClipperCache;
use \DateTime;

/**
 * ClipperCacheRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ClipperCacheRepository extends EntityRepository
{
  /**
   * Helper method to count cache records.
   * @method count
   *
   * @param  boolean $active_only
   *    Flag to count all / to which still active.
   *
   * @return integer
   *    Found record count.
   */
  public function count($active_only = FALSE) {
    $qb = $this->getEntityManager()->createQueryBuilder();
    $qb->select('COUNT(c.name)');
    $qb->from('PPSampleBundle:ClipperCache','c');
    if ($active_only) {
      $now = new DateTime();
      $qb->where('c.expiries >= :now');
      $qb->setParameter('now', $now, \Doctrine\DBAL\Types\Type::DATETIME);
    }
    return (int) $qb->getQuery()->getSingleScalarResult();
  }

  /**
   * Helper method to flush cache records.
   * @method flush
   *
   * @param  boolean $all
   *    Flag to remove all cache records.
   *
   * @return integer
   *    Removed records count.
   */
  public function flush($all = FALSE) {
    $qb = $this->getEntityManager()->createQueryBuilder();
    $qb->delete('PPSampleBundle:ClipperCache', 'c');
    if (!$all) {
      $now = new DateTime();
      $qb->where('c.expiries <= :now');
      $qb->setParameter('now', $now, \Doctrine\DBAL\Types\Type::DATETIME);
    }
    return $qb->getQuery()->execute();
  }

  /**
   * Helper method to remove cache record by name.
   * @method remove
   *
   * @param  object $cache_record
   *    \ClipperCache object.
   *
   * @return boolean
   *    Remove complete.
   */
  public function remove($cache_record) {
    if ((empty($cache_record)) || (!is_object($cache_record))) {
      return FALSE;
    }
    $em = $this->getEntityManager();
    $em->remove($cache_record);
    $em->flush();
    return TRUE;
  }
}